<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <title>Summarization Page</title>
</head>
<body>
    <button id="logout-button" onclick="logOut()">Log Out</button>
    <button id="chat-button" onclick="toggleChat()">Chat</button>
    <div class="file-menu" id="uploaded-files-menu">
        <button class="file-menu-title" onclick="toggleMenu('uploaded-files-menu')">
            Accepted Files
        </button>
        <input type="file" id="fileUpload" accept=".pdf" style="display:none;">
        <button onclick="document.getElementById('fileUpload').click();">Upload Here</button>
        <ul id="uploaded-file-list"></ul>
        <button id="synthesize-button" class="synthesize-button">Synthesize</button>
    </div>

    <div class="left-panel" id="left-panel">
        <div class="pdf-container" id="pdf-container">
            <p>Select a PDF to preview it here.</p>
        </div>
    </div>

    <div class="resize-bar" id="resize-bar-2"></div>

    <div class="file-menu" id="generated-files-menu">
        <button class="file-menu-title" onclick="toggleMenu('generated-files-menu')">
            Generated Files
        </button>
        <ul id="generated-file-list"></ul>
        <button id="accept-output-button" class="accept-output-button">Accept Output</button>
    </div>

    <div class="right-panel" id="right-panel">
        <textarea id="text-editor" class="text-editor"></textarea>
    
        <button id="save-button" class="save-button">Save</button>
    
        <div class="chat-overlay" id="chat-overlay">
            <div class="chat-header">
                <span>Chat</span>
                <button style="background: none; border: none; color: white; cursor: pointer;" 
                        onclick="toggleChat()">X</button>
            </div>
            <div class="chat-messages" id="chat-messages"></div>
            <div class="chat-input">
                <input type="text" id="chat-input" placeholder="Type your message...">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script>
        function toggleMenu(menuId) {
            const menu = document.getElementById(menuId);
            menu.classList.toggle('hidden');
        }

        document.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {
                const chatOverlay = document.getElementById('chat-overlay');
                if (chatOverlay.classList.contains('open')) {
                    toggleChat();
                }
            }
        });
        const chatMessages = document.getElementById('chat-messages');
        function generateText(inputs) {
            return fetch(`https://us-central1-praximai-438817.cloudfunctions.net/get_request`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    action: 'generate_text',
                    input_prompt: inputs,
                }),
                mode: 'cors'
            })
            .then(response => {
                if (!response.ok) {
                throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(json => {
                const response_result = json.result;
                console.log('Response Result:', response_result);
                return response_result;
            })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
            });
        }

        let conversationHistory = ""; 
        let fileHistory = "";
        let chatInitialized = false;  // Track whether the chat has been initialized
        function initializeChat() {
            const botMessage = "Hi, I'm Praxim! How can I help you with this case?";

            // Create a new paragraph element for the bot's message
            const nextMessage = document.createElement('p');
            nextMessage.innerHTML = `<strong>Praxim:</strong> ${botMessage}`;

            // Append the message to the chat-messages container
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.appendChild(nextMessage);

            // Scroll to the bottom of the chat
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Mark the chat as initialized
            chatInitialized = true;
        }

        // Modified toggleChat function to trigger chat initialization
        function toggleChat() {
            const chatOverlay = document.getElementById('chat-overlay');
            chatOverlay.classList.toggle('open');
            if (!chatInitialized) {
                initializeChat();
            }
        }

        async function getGeneratedText(){
            const user = auth.currentUser;
            if (!user) {
                console.log('No user signed in.');
                return;
            }
            let allFiles = [];
            const q = query(fileCollection, where("uid", "==", user.uid));
            const querySnapshot = await getDocs(q);
            querySnapshot.forEach((doc) => {
                const data = doc.data();
                allFiles.push({
                    name: data.name,
                    url: data.url
                });
            });
            return generateRAG(allFiles);
        }

        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim(); // Get user input

            if (message) {
                conversationHistory += `User: ${message}\n`;
                const newMessage = document.createElement('p');
                newMessage.innerHTML = `<strong>You:</strong> ${message}`;
                chatMessages.appendChild(newMessage);

                // Clear input field and scroll to the bottom
                input.value = '';
                chatMessages.scrollTop = chatMessages.scrollHeight;
                totalHistory = fileHistory + conversationHistory;
                generateText(totalHistory).then(result => {
                    conversationHistory += `YOU: ${result}\n`;
                    const nextMessage = document.createElement('p');
                    nextMessage.innerHTML = `<strong>Praxim:</strong> ${result}`;
                    chatMessages.appendChild(nextMessage);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                });
            }
        }

        // Trigger sendMessage on Enter key press
        document.getElementById('chat-input').addEventListener('keydown', function (event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        });

        const resizeBar2 = document.getElementById('resize-bar-2');
        const leftPanel = document.getElementById('left-panel');
        const rightPanel = document.getElementById('right-panel');
        let isDragging = false;
        let startX;

        resizeBar2.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX;

            const initialLeftWidth = leftPanel.getBoundingClientRect().width;
            const initialRightWidth = rightPanel.getBoundingClientRect().width;

            const onMouseMove = (event) => {
                if (isDragging) {
                    const deltaX = event.clientX - startX;
                    const newLeftWidth = initialLeftWidth + deltaX;
                    const newRightWidth = initialRightWidth - deltaX;

                    if (newLeftWidth >= 0 && newRightWidth >= 0) {
                        leftPanel.style.flex = `${newLeftWidth} 1 0%`;
                        rightPanel.style.flex = `${newRightWidth} 1 0%`;
                    }
                }
            };

            const onMouseUp = () => {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script type="module">
        // Import necessary Firebase functions
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js';
        import { getAuth, signOut } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDocs, deleteDoc, setDoc, doc, updateDoc} from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-storage.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBZvsBcAoIJLbQc4yINQz78oyCovB4RDTA",
            authDomain: "praximai-438817.firebaseapp.com",
            projectId: "praximai-438817",
            storageBucket: "praximai-438817.appspot.com",
            messagingSenderId: "274586621759",
            appId: "1:274586621759:web:b9f20b3da3329327eba58a",
            measurementId: "G-EQ7HTDC8T3"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);

        const fileCollection = collection(db, 'pdfFiles');

        // Handle authentication
        auth.onAuthStateChanged((user) => {
            if (!user) {
                window.location.href = "../";
            }
            else {
                listDocuments();
                listGenerateDocuments();
            }
        });

        // Logout function
        window.logOut = function() {
            auth.signOut().then(() => {
                window.location.href = "../";
            }).catch((error) => {
                console.error("Error during logout", error);
            });
        };

        // upload documents
        const pdfUpload = document.getElementById('fileUpload');
        pdfUpload.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (file && file.type === 'application/pdf') {
                try {
                    const user = auth.currentUser;
                    if (!user) {
                        alert('You must be logged in to upload files.');
                        return;
                    }
                    const modifiedFileName = user.uid + '_' + file.name;
                    const storageRef = ref(storage, 'documents/' + modifiedFileName);
                    await uploadBytes(storageRef, file);
                    const url = await getDownloadURL(storageRef);
                    await addDoc(fileCollection, {
                        name: file.name,
                        storageName: modifiedFileName,
                        url: url,
                        uid: user.uid,
                        isOriginal: true
                    });
                    console.log('Uploaded and added to Firestore:', file.name);
                    fileHistory = getGeneratedText();
                    listDocuments();
                    listGenerateDocuments();
                } catch (error) {
                    console.error('Upload failed:', error);
                }
            } else {
                alert('Please upload a PDF file.');
            }
        });

        // create ORIGINAL list
        import { query, where, and} from 'https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js';
        const fileMenu = document.getElementById('uploaded-file-list');
        async function listDocuments() {
            const user = auth.currentUser;
            if (!user) {
                console.log('No user signed in.');
                return;
            }

            try {
                fileMenu.innerHTML = '';
                const q = query(fileCollection, and(
                    where("uid", "==", user.uid),
                    where("isOriginal", "==", true)
                ));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((docSnapshot) => {
                    const fileData = docSnapshot.data();
                    addToFileMenu(fileData.name, fileData.url);
                });
            } catch (error) {
                console.error('Error listing documents:', error);
            }
        }

        let selectedFiles = []; // Global list to store selected file data

        // Modify the addToFileMenu function to include a checkbox
        function addToFileMenu(fileName, fileUrl) {
            const li = document.createElement('li');
            li.textContent = fileName;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.style.marginLeft = '10px'; // Adjust spacing between name and checkbox

            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    selectedFiles.push({ name: fileName, url: fileUrl });
                } else {
                    selectedFiles = selectedFiles.filter(file => file.url !== fileUrl);
                }
            });
            li.appendChild(checkbox); // Add the checkbox to the list item
            li.addEventListener('click', () => displayPDF(fileName, fileUrl));
            fileMenu.appendChild(li);
        }

        // Function to call uploadRAG with selected files
        function synthesizeDocuments() {
            if (selectedFiles.length === 0) {
                alert('No files selected for synthesis.');
                return;
            }
            uploadRAG(selectedFiles);
            // Clear the global selected files list
            selectedFiles = [];

            // Uncheck all checkboxes
            const checkboxes = document.querySelectorAll('#uploaded-file-list input[type="checkbox"]');
            checkboxes.forEach(checkbox => checkbox.checked = false);
        }

        document.getElementById('synthesize-button').addEventListener('click', synthesizeDocuments);
        // create GENERATE list
        async function listGenerateDocuments() {
            const user = auth.currentUser;
            if (!user) {
                console.log('No user signed in.');
                return;
            }

            try {
                generateMenu.innerHTML = '';
                const q = query(fileCollection, and(
                    where("uid", "==", user.uid),
                    where("isOriginal", "==", false)
                ));
                const querySnapshot = await getDocs(q);
                querySnapshot.forEach((docSnapshot) => {
                    const fileData = docSnapshot.data();
                    addToGenerateMenu(fileData.name, fileData.url);
                });
            } catch (error) {
                console.error('Error listing documents:', error);
            }
        }
        // add to generate menu
        const generateMenu = document.getElementById('generated-file-list');
        let selectedGeneratedFiles = [];
        function addToGenerateMenu(fileName, fileUrl) {
            const gen_li = document.createElement('li');
            gen_li.textContent = fileName;

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.style.marginLeft = '10px'; // Spacing

            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    selectedGeneratedFiles.push({ name: fileName, url: fileUrl });
                } else {
                    selectedGeneratedFiles = selectedGeneratedFiles.filter(file => file.url !== fileUrl);
                }
            });

            gen_li.appendChild(checkbox);
            gen_li.addEventListener('click', () => displayGeneratedText(fileName, fileUrl));
            generateMenu.appendChild(gen_li);
        }

        // display the current original pdf
        const pdfContainer = document.getElementById('pdf-container');
        let currentPdf = null;  // Store the currently loaded PDF
        let canvases = [];      // Store references to canvas elements

        // Display the PDF only once
        async function displayPDF(fileName, fileUrl) {
            fetch(fileUrl)
                .then((response) => response.arrayBuffer())
                .then((pdfData) => {
                    pdfjsLib.getDocument({ data: pdfData }).promise.then((pdf) => {
                        currentPdf = { pdf, fileName, fileUrl };  // Store the loaded PDF
                        pdfContainer.innerHTML = '';  // Clear previous content
                        canvases = [];  // Reset canvas storage

                        for (let i = 1; i <= pdf.numPages; i++) {
                            const canvas = document.createElement('canvas');
                            canvas.style.display = 'block';
                            canvas.style.margin = '10px 10px';
                            pdfContainer.appendChild(canvas);
                            canvases.push(canvas);  // Store the canvas for later rescaling
                            renderPage(pdf, i, canvas);
                        }
                    });
                })
                .catch((error) => {
                    console.error('Error displaying PDF:', error);
                });
        }

        // Render individual pages only once
        function renderPage(pdf, pageNumber, canvas) {
            pdf.getPage(pageNumber).then((page) => {
                const initialViewport = page.getViewport({ scale: 2 });
                const context = canvas.getContext('2d');

                // Set canvas size based on the initial viewport
                canvas.width = initialViewport.width;
                canvas.height = initialViewport.height;

                // Render the page content onto the canvas
                page.render({ canvasContext: context, viewport: initialViewport }).promise.then(() => {
                    console.log(`Rendered page ${pageNumber}`);
                    // Scale the canvas to fit the container initially
                    rescaleCanvas(canvas, initialViewport);
                });
            }).catch((error) => {
                console.error(`Error rendering page ${pageNumber}:`, error);
            });
        }

        // Rescale canvas on resize
        function rescaleCanvas(canvas, viewport) {
            const containerWidth = pdfContainer.clientWidth;  // Get current container width
            const scale = 0.94 * containerWidth / viewport.width;  // Calculate the new scale

            // Apply scaled dimensions using CSS (without affecting the internal canvas resolution)
            canvas.style.width = `${viewport.width * scale}px`;
            canvas.style.height = `${viewport.height * scale}px`;
        }

        // Listen for resize events and rescale the canvases
        const resizeObserver = new ResizeObserver(() => {
            canvases.forEach((canvas) => {
                const viewport = canvas.viewport || { width: canvas.width, height: canvas.height };
                rescaleCanvas(canvas, viewport);  // Rescale each canvas
            });
        });

        // Start observing the left panel for resizes
        resizeObserver.observe(document.getElementById('left-panel'));
        const textContainer = document.getElementById('text-container');

        // Load text into the editor
        async function displayGeneratedText(fileName, fileUrl) {
            fetch(fileUrl)
            .then(response => response.text())
            .then((text) => {
                const textEditor = document.getElementById('text-editor');
                textEditor.value = text; // Load text into textarea
                textEditor.dataset.fileName = fileName;
                textEditor.dataset.fileUrl = fileUrl;
            })
            .catch((error) => console.error('Error loading text:', error));
        }

        // Save edited text back to the original location
        // Save edited text back to Firebase Storage and update Firestore metadata
        document.getElementById('save-button').addEventListener('click', async () => {
            const textEditor = document.getElementById('text-editor');
            const editedText = textEditor.value;
            const fileName = textEditor.dataset.fileName;
            const fileUrl = textEditor.dataset.fileUrl;

            try {
                const user = auth.currentUser;
                if (!user) {
                    alert('You must be logged in to save the document.');
                    return;
                }

                // Step 1: Retrieve the metadata object from Firestore
                const q = query(fileCollection, where('uid', '==', user.uid), where('url', '==', fileUrl));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    alert('Document metadata not found.');
                    return;
                }

                const docSnapshot = querySnapshot.docs[0];
                const fileData = docSnapshot.data();

                // Step 2: Overwrite the file in Firebase Storage
                const storageRef = ref(storage, 'texts/' + fileData.storageName);
                const textBlob = new Blob([editedText], { type: 'text/plain' });
                await uploadBytes(storageRef, textBlob);

                // Step 3: Get the new URL for the uploaded file
                const newUrl = await getDownloadURL(storageRef);

                // Step 4: Update Firestore metadata without changing 'isOriginal'
                await updateDoc(docSnapshot.ref, { url: newUrl });

                alert('Document saved successfully!');

                // Step 5: Refresh the lists to reflect the changes
                listDocuments();
                listGenerateDocuments();
            } catch (error) {
                console.error('Error saving document:', error);
                alert('Failed to save the document.');
            }
        });


        // update the generated storage
        async function uploadGeneration(filename, fileUrl) {
            try {
                const summaryText = await generateSummary(fileUrl);
                const user = auth.currentUser;
                if (!user) {
                    alert('You must be logged in to upload files.');
                    return;
                }
                const textBlob = new Blob([summaryText], { type: 'text/plain' });
                const modifiedFileName = user.uid + '_' + filename + '_summary.txt';
                const modName = filename.replace(/\.pdf$/i, "") + "_generated";
                const storageRef = ref(storage, 'texts/' + modifiedFileName);
                await uploadBytes(storageRef, textBlob);
                const url = await getDownloadURL(storageRef);
                await addDoc(fileCollection, {
                    name: modName,
                    storageName: modifiedFileName,
                    url: url,
                    uid: user.uid,
                    isOriginal: false
                });
            }  catch (error) {
                console.error('Upload failed:', error);
            }
        }

        // update the generated storage with a RAG sumary
        async function uploadRAG(selectedFiles){
            let fileNameList = [];
            let fileUrlList = [];
            selectedFiles.forEach(file => {
                fileNameList.push(file.name);
                fileUrlList.push(file.url);
            });
            try {
                const summaryText = await generateRAG(fileUrlList);

                const user = auth.currentUser;
                if (!user) {
                    alert('You must be logged in to upload files.');
                    return;
                }
                const q = query(fileCollection, where('uid', '==', user.uid), where('name', '>=', 'RAG_summary'), where('name', '<', 'RAG_summary' + '\uf8ff'));

                const querySnapshot = await getDocs(q);
                let count = 0;
                querySnapshot.forEach((docSnapshot) => {
                    count += 1;
                });

                const textBlob = new Blob([summaryText], { type: 'text/plain' });
                const combinedNames = fileNameList.join('_');
                const modifiedFileName = user.uid + combinedNames;
                const modName = "RAG_summary" + '_' + count;
                const storageRef = ref(storage, 'texts/' + modifiedFileName);
                await uploadBytes(storageRef, textBlob);
                const url = await getDownloadURL(storageRef);
                await addDoc(fileCollection, {
                    name: modName,
                    storageName: modifiedFileName,
                    url: url,
                    uid: user.uid,
                    isOriginal: false
                });
                fileHistory = getGeneratedText();
                listGenerateDocuments();
            }  catch (error) {
                console.error('Upload failed:', error);
            }
        }

        // accepts output and clears selected generated files
        const acceptOutput = document.getElementById('accept-output-button');
        acceptOutput.addEventListener('click', async (event) => {
            if (selectedGeneratedFiles.length === 0) {
                alert('No files selected to accept.');
                return;
            }
            await moveGenerated(selectedGeneratedFiles);
            selectedGeneratedFiles = [];
            listDocuments();
            listGenerateDocuments();
        });

        // replaces generated text with pdf and moves to upload files
        async function moveGenerated(selectedGeneratedFiles) {
            let fileNameList = [];
            let fileUrlList = [];
            selectedGeneratedFiles.forEach(file => {
                fileNameList.push(file.name);
                fileUrlList.push(file.url);
            });

            try {
                const user = auth.currentUser;
                if (!user) {
                    alert('You must be logged in to upload files.');
                    return;
                }

                const promises = fileUrlList.map(async (fileUrl) => {
                    const q = query(fileCollection, and(
                        where("uid", "==", user.uid),
                        where("url", "==", fileUrl)
                    ));
                    const querySnapshot = await getDocs(q);
                    const innerPromises = querySnapshot.docs.map(async (docSnapshot) => {
                        const fileData = docSnapshot.data();
                        const response = await fetch(fileUrl);
                        const text = await response.text();

                        // Initialize jsPDF with A4 page size
                        const { jsPDF } = window.jspdf;
                        const newdoc = new jsPDF({
                            format: 'a4', // Standard A4 size
                            unit: 'pt', // Points for better precision
                        });

                        const pageWidth = newdoc.internal.pageSize.getWidth();
                        const pageHeight = newdoc.internal.pageSize.getHeight();
                        const margin = 40; // Margin from all sides
                        const maxWidth = pageWidth - 2 * margin;

                        // Split the text into lines to fit the page width
                        const lines = newdoc.splitTextToSize(text, maxWidth);
                        let cursorY = margin;

                        // Add text to PDF page-by-page
                        lines.forEach((line) => {
                            if (cursorY + 20 > pageHeight - margin) {
                                newdoc.addPage(); // Add a new page when content overflows
                                cursorY = margin; // Reset Y position for new page
                            }
                            newdoc.text(line, margin, cursorY);
                            cursorY += 20; // Move down for the next line
                        });

                        const pdfBlob = newdoc.output('blob'); // Create PDF blob

                        // Replace old file with the new PDF in Firebase storage
                        const storageRef = ref(storage, 'texts/' + fileData.storageName);
                        await deleteObject(storageRef);
                        const newStorageRef = ref(storage, 'documents/' + fileData.storageName);
                        await uploadBytes(newStorageRef, pdfBlob);
                        const newurl = await getDownloadURL(newStorageRef);

                        // Update Firestore document with new PDF URL
                        const docRef = docSnapshot.ref;
                        await updateDoc(docRef, { url: newurl, isOriginal: true });
                    });
                    return Promise.all(innerPromises);
                });

                await Promise.all(promises);
            } catch (error) {
                console.error('Upload failed:', error);
            }
        }

        // call summarize function to create generated text
        function generateSummary(fileUrl) {
            return fetch(`https://us-central1-praximai-438817.cloudfunctions.net/get_request`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    action: 'generate_summary',
                    input_prompt: fileUrl,
                }),
                mode: 'cors'
            })
            .then(response => {
                if (!response.ok) {
                throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(json => {
                const response_result = json.result;
                console.log('Response Result:', response_result);
                return response_result;
            })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
            });
        }

        // call RAG function to create RAG generated text
        function generateRAG(fileUrlList) {
            return fetch(`https://us-central1-praximai-438817.cloudfunctions.net/get_request`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    action: 'generate_rag',
                    input_list: fileUrlList,
                }),
                mode: 'cors'
            })
            .then(response => {
                if (!response.ok) {
                throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(json => {
                const response_result = json.result;
                console.log('Response Result:', response_result);
                return response_result;
            })
                .catch(error => {
                    console.error('There has been a problem with your fetch operation:', error);
            });
        }
    </script>